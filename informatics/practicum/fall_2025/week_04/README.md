# Побитови операции

### Теоретичен обзор

#### 1. Дефиниция и основни оператори

Побитовите оператори работят директно върху отделните битове на операндите. Те са основни инструменти за нисконивови манипулации на данни, като се използват за контрол на флагове, криптиране и оптимизации.

| Оператор | Име | Действие |
|----------|----------|----------|
| `&` | Побитово И (AND) | Резултатният бит е 1 само ако и двата съответни бита са 1. Използва се за изчистване или проверка на бит. |
| `\|` | Побитово ИЛИ (OR) | Резултатният бит е 1, ако поне един от съответните битове е 1. Използва се за задаване на бит. |
| `^` | Побитово изключващо ИЛИ (XOR) | Резултатният бит е 1, ако само един от съответните битове е 1 (т.е. битовете са различни). Използва се за обръщане на бит или за размяна на стойности. |
| `~` | Побитово отрицание (NOT) | Инвертира всеки бит (0 става 1, 1 става 0). Това е унарен оператор. |
| `<<` | Изместване наляво (LSHIFT) | Измества всички битове наляво с определен брой позиции. Еквивалентно на **умножение** с `2^k`. |
| `>>` | Изместване надясно (RSHIFT) | Измества всички битове надясно. Еквивалентно на **деление** с `2^k`. |

Следващият пример демонстрира използването на шестте основни побитови оператора в езика C.

```c
#include <stdint.h>
#include <stdio.h>

int main() {
    // 00000101
    uint8_t a = 5;

    // 00000011
    uint8_t b = 3;

    printf("a & b = %u\n", a & b);
    printf("a << 1 = %u\n", a << 1);
    printf("a >> 1 = %u\n", a >> 1);
    printf("a ^ b = %u\n", a ^ b);
    printf("a | b = %u\n", a | b);
    printf("~a = %u\n", (uint8_t)~a);

    return 0;
}
```

#### 2. Съвместимост и ограничения на типовете данни

Побитовите операции са фундаментални за нисконивово програмиране, хардуерен контрол и оптимизации на производителността. Те са разрешени само за **цели** типове данни.

| Тип данни | Разрешено? | Бележка |
|----------|----------|----------|
| Беззнакови (`unsigned int`, `uint8_t`, `size_t` и др.) | Да | Препоръчителни за побитови операции. Всички оператори (`&`, `\|`, `^`, `~`, `<<`, `>>`) имат **добре дефинирано** и предвидимо поведение. |
| Знакови (`int`, `char`, `long` и др.) | Да, но с **висок риск** | Трябва да се внимава с **недефинирано поведение**. Операциите `~` (NOT) и `<<` (LSHIFT) могат да променят знаковия бит (MSB) и да направят резултата невалиден. Поведението на `>>` (RSHIFT) е **зависимо от имплементацията** (компилатора). |
| Плаваща запетая (`float`, `double`) | Не | Тези типове имат специален формат - **IEEE 754** - с отделни полета за знак, експонента и мантиса. Побитовите операции върху тях водят до **грешка при компилация**. |

#### 3. Представяне на отрицателни числа (Two's Complement)

Системата **"допълнение до две"** е стандартният начин, по който компютрите представят отрицателните цели числа. Този метод позволява събирането и изваждането да се извършват с едни и същи хардуерни схеми.

Всяко целочислено представяне, независимо дали е знаково (`signed`) или беззнаково (`unsigned`), използва един и същ брой битове (`N`) и може да съхранява общо `2^N` уникални стойности.

За 8-битов тип (`N = 8`, `2^8 = 256` стойности):

| Тип данни | Общ брой стойности | Диапазон |
|----------|----------|----------|
| Беззнаков (`uint8_t`) | 256 | `[0, 255]` |
| Знаков (`int8_t`) | 256 | `[-128, 127]` |

При знаковото представяне, тези 256 комбинации се разделят по следния начин:

- **Положителни числа и нула**
	- Най-левият бит (MSB) е 0
	- Всички комбинации, започващи с 0 (от `00000000` до `01111111`)
	- Приемат положителни стойности от 0 до 127
- **Отрицателни числа**
	- Най-левият бит (MSB) е 1
	- Всички комбинации, започващи с 1 (от `10000000` до `11111111`)
	- Приемат отрицателни стойности от -128 до -1

| Описание (8 бита) | Двоично | Беззнаково (`uint8_t`) | Знаково (`int8_t`) |
|----------|----------|----------|----------|
| +5 | `00000101` | 5 | 5 |
| -5 (Two's Complement) | `11111011` | 251 | -5 |

Числото -5 е равно на 251, защото и двете стойности се представят от **една и съща** двоична последователност (`11111011`) в 8-битовата памет, а разликата идва единствено от начина, по който компютърът **интерпретира** тази последователност.

Отрицателното число `-N` се получава като инвертиране на всички битове на `N` (`~N`), последвано от добавяне на 1: `-N = ~N + 1`.

```c
#include <stdint.h>
#include <stdio.h>

int main() {
    int8_t n = 5;
    int8_t neg = ~n + 1;

    printf("n = %d (0x%02X)\n", n, (uint8_t)n);
    printf("~n = %d (0x%02X)\n", (int8_t)~n, (uint8_t)~n);

    printf("~n + 1 = %d (0x%02X)\n", neg, (uint8_t)neg);

    return 0;
}
```

#### 4. Особености и рискове при побитови операции със знакови типове

Прилагането на побитови операции върху знакови типове (`signed`) трябва да се избягва, тъй като е източник на непредвидимост. В зависимост от конкретния компилатор и архитектура, операциите могат да предизвикат **недефинирано поведение**, особено когато засягат най-левия (знаковия) бит. Това прави кода непреносим и труден за дебъгване.

| Оператор | Риск |
|----------|----------|
| `~x` | Винаги обръща **знаковия бит**, което може да доведе до неочаквана промяна (напр. `~5` → `-6`). |
| `<<` | Недефинирано поведение. Ако изместването наляво промени знаковия бит от 0 на 1 (т.е. превърне положително число в отрицателно), резултатът е непредсказуем. |
| `>>` | Несигурно. Компилаторът решава дали изместването ще бъде **аритметично** (копира знаковия бит, запазвайки знака) или **логическо** (вмъква нули). Липса на преносимост. |

За да гарантирате, че кодът ви е **преносим** и **надежден**, винаги използвайте **беззнакови** типове (`uint8_t`, `uint32_t` и т.н.) за всички побитови операции. Това гарантира, че поведението на изместването и инверсията е **добре дефинирано** (логическо) и не зависи от архитектурата.

---

### Полезни съвети

Използването на побитови операции води до по-ефективен и компактен код, но изисква **повишено внимание** поради ниското ниво на абстракция.

| Принцип | Цел |
|----------|----------|
| Битово маскиране | Използване на константна **маска** (напр. `0x0F` или `1 << 4`) с операторите `&` или `\|` за **изолиране, задаване или изчистване** на конкретен бит/битове, без да се засягат останалите. |
| Оптимизация на аритметиката | Заместване на стандартното умножение и деление с `x << 1` и `x >> 1`, тъй като битовите отмествания са **значително по-бързи**. |
| Проверка за четност | Проверка дали най-десният бит е зададен: `(number & 1)`. Ако резултатът е 1, числото е нечетно; ако е 0, значи е четно. |

---

### Допълнителни ресурси

- [Bitwise Operations in C](https://en.wikipedia.org/wiki/Bitwise_operations_in_C)
- [Integer Representations](https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Integer-Representations.html)
- [Two's Complement](https://en.wikipedia.org/wiki/Two%27s_complement)