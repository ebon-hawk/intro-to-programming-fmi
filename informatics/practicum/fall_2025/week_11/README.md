# Динамична памет

### Теоретичен обзор

#### 1. Типове памет и живот на данните в C

Когато една програма работи, тя използва различни области от оперативната памет. Тези области се различават по това *кога се създават данните*, *колко дълго живеят* и *кой ги управлява*.

В C има три основни места, където могат да се съхраняват данни.

<p>
<details style="margin-left: 20px;">
<summary><b>Статична памет (static storage)</b></summary>

В тази област се разполагат *глобални променливи*, *статични локални променливи* и *константни низове*.

Характеристики:

- Паметта остава **запазена през цялото време на изпълнение** на програмата
- Данните в нея **се инициализират само веднъж** и се пазят докато програмата приключи
- Подходяща е за **стойности и конфигурации**, които трябва да бъдат налични независимо от това коя функция се изпълнява и дали е излязла от обхват

```c
// Глобална променлива с външна видимост
int counter = 0;

// Глобална променлива със статична (вътрешна) видимост - достъпна само в този файл
static int calls = 0;

void increment_calls() {
    // Локална статична променлива, която запазва стойността си между извикванията
    static int local_count = 0;
	
    ++calls;
    ++counter;
    ++local_count;
}
```

> **Бележка:** В езика C глобалните променливи без ключовата дума `static` имат **външна видимост** - тоест могат да бъдат достъпвани и от други файлове. От друга страна, глобалните променливи, декларирани със `static`, имат **вътрешна видимост** и са достъпни само в рамките на файла, в който са дефинирани. Това позволява да се избегнат конфликти при имената и да се скрие вътрешната реализация на даден модул. Локалните променливи със `static` пък запазват стойността си между различните извиквания на функцията, като се инициализират само веднъж и живеят през цялото изпълнение на програмата.

</details>
<details style="margin-left: 20px;">
<summary><b>Стекова памет (stack)</b></summary>

Това е областта, която се използва при извикване на функции. В нея се съхраняват *параметрите на функциите*, както и *локалните автоматични променливи*. Идеална за краткотрайни данни, които не трябва да се запазват след приключване на функцията.

Характеристики:

- Паметта се управлява *автоматично* от системата (отделя се при влизане във функция и се освобождава при излизане)
- Достъпът е **много бърз**, тъй като работи със статични офсети от stack pointer
- Размерът е *ограничен*, което го прави неподходящ за големи структури от данни

```c
void func() {
    // Локална променлива (изчезва след края на функцията)
    int x = 5;
}
```

</details>
<details style="margin-left: 20px;">
<summary><b>Динамична памет (heap)</b></summary>

Това е областта от паметта, от която програмата може да заделя място **по време на изпълнение** - когато размерът на данните не е известен предварително или може да се променя.

Характеристики:

- Паметта може да бъде **много голяма** (в пъти повече от stack-а)
- Данните в нея **запазват живота си**, докато програмистът изрично не ги освободи
- Позволява работа със **структури с променлив размер**, които не могат да се поберат в stack-а
- Управлява се *ръчно* чрез `malloc`, `calloc`, `realloc` и `free`

```c
// Заделяме динамична памет
int* p = malloc(10 * sizeof(int));

// Освобождаваме я ръчно
free(p);
```

Heap-ът е необходим, когато:

- Данните трябва да живеят **по-дълго от изпълнението на една функция**
- Размерът на структурата е **непредвидим или голям**
- Искаме да създаваме и унищожаваме обекти **гъвкаво и динамично**

</details>
</p>

За да можем да работим с памет, която **продължава да съществува след като функцията приключи**, или с памет, която заделяме динамично по време на изпълнението на програмата, ни трябва начин да **посочваме конкретното място в паметта, където се съхраняват тези данни**. Това става чрез *указател* - променлива, която съдържа **адреса на определена клетка в паметта**, където са разположени тези данни, и ни позволява да ги достъпваме и променяме директно.

#### 2. Какво представлява указател (pointer) в C?

Указателят е **променлива, която съдържа адрес в паметта**. Това е число, което показва мястото, където се намира стойността в паметта.

Паметта представлява поредица от клетки с уникални адреси:

```
Адрес:   Стойност:
0x1000 → [ 10 ]
0x1004 → [ 20 ]
0x1008 → [ 30 ]
0x100C → [ 40 ]

       ^
       |
int* p = 0x1000
```

Указателите позволяват:

- Директен достъп до конкретен адрес в паметта, където е съхранена стойност
- Предаване на адреси като аргументи на функции, вместо копиране на данни
- Управление на динамично заделена памет

Декларация на указател:

```c
// Тук `p` е променлива, която съдържа адрес към `int`
int* p;
```

Вземане на адрес с оператора `&`:

```c
int x = 10;

// Променливата `p` съдържа адреса на `x`
int* p = &x;
```

Достъпване до стойността чрез указател с оператора `*` (дереференция):

```c
// Отива на адреса, който е в `p`, и взима стойността там, след което я извежда
printf("%d\n", *p);
```

Какво не е указател:

- Не е самата стойност, ами нещо, което *сочи* към нея
- Не е масив, макар че масивите могат да се използват като указатели
- Не съдържа няколко числа, а едно единствено - адрес

```c
int x = 10;
int* p = &x;

// Отпечатва адреса на x
printf("%p\n", p);

// Отпечатва 10
printf("%d\n", *p);

*p = 20;

// Отпечатва 20
printf("%d\n", x);
```

#### 3. Функции за динамично заделяне (`malloc`, `calloc`, `realloc` и `free`)

Стандартната библиотека `<stdlib.h>` предоставя четири ключови функции:

- `malloc(size)`
	- Заделя `size` байта
	- Връща `void *` - адрес към новозаделен блок
	- Не инициализира паметта (съдържанието е неопределено)
	
	```c
	// Блок за 5 int-а
	int* p = malloc(5 * sizeof(int));
	```
- `calloc(n, size)`
	- Заделя памет за `n` елемента, всеки с размер `size` байта (`n * size` общо)
	- Инициализира всички байтове с 0 (съставящите ги битове са само нулеви)
	- Удобно за масиви
	
	```c
	// 5 int-а, всичките 0
	int* a = calloc(5, sizeof(int));
	```
	
	<p>
	<details style="margin-left: 20px;">
	<summary><b>Опростена вътрешна реализация</b></summary>
	
	```c
	void* calloc(size_t n, size_t size) {
		size_t total = n * size;
		void* p = malloc(total);
		
		if (p) memset(p, 0, total);
		
		return p;
	}
	```
	
	</details>
	</p>
- `realloc(ptr, new_size)`
	- Променя размера на вече заделен блок памет
	- Ако има място, разширява или свива блока **в същата памет** и връща същия указател
	- Ако не може да го направи на същото място:
		- Заделя нов блок с желания размер
		- Копира старите данни (до `min(old_size, new_size)`) в новия блок в същия ред
		- Освобождава стария блок
		- Връща новия указател
	- Ако не успее да задели памет, връща `NULL` и старият блок остава непокътнат и валиден
	- Старият `ptr` става *невалиден* след успешно преместване
	
	```c
	// Разширяване до 10 елемента
	p = realloc(p, 10 * sizeof(int));
	```
- `free(ptr)`
	- Освобождава блок, заделен с `malloc`/`calloc`/`realloc`
	- След `free(ptr)` указателят става *висящ* (dangling)
	
	```c
	free(p);
	
	// Добра практика
	p = NULL;
	```
	
	> **Бележка:** `NULL` е макрос, който представлява специална стойност на указател, означаваща, че той **не сочи към валиден адрес в паметта**. Обикновено е дефиниран като `(void *)0` или само 0. Използва се за означаването на "празен" или "неинициализиран" указател и позволява лесна проверка за валидност.

#### 4. Семантика на динамичните блокове

Типът на резултата от `malloc`/`calloc`/`realloc` е **`void *`**, което означава:

- Няма асоцииран базов тип
- Няма информация за броя елементи
- Паметта е просто поредица от байтове

Програмистът определя как да използва блока чрез *кастване* или присвояване към конкретен указател.

```c
// Интерпретация като 10 double-а
double* d = malloc(10 * sizeof(double));
```

Типът е *указател към първия елемент на непрекъснато поле от `N` елемента от тип `T`*.

#### 5. Заделяне на едномерен динамичен масив

```c
int n = 20;

double* arr = malloc(n * sizeof(double));
```

- `arr` е указател към първия елемент
- Индексацията работи нормално: `arr[i]`
- Броят елементи се пази *от програмиста*, компилаторът не го знае

#### 6. Заделяне на двумерен динамичен масив

**Вариант А (масив от указатели - `T **`):**

```c
// Заделя се масив от указатели за редовете, после всеки ред се заделя отделно
int** m = malloc(rows * sizeof(int *));

for (int i = 0; i < rows; ++i)
    m[i] = malloc(cols * sizeof(int));
```

Плюсове:

- Всеки ред може да има различен размер
- Удобна логика за jagged arrays

Минуси:

- Паметта не е един блок (по-лош кеш)
- `free` е по-сложно (трябва по редове + главния указател)
- Не е съвместимо с функции, очакващи `int a[][C]`

**Вариант Б (един голям блок + масив от указатели):**

```c
int* data = malloc(rows * cols * sizeof(int));
int** m = malloc(rows * sizeof(int *));

for (int i = 0; i < rows; ++i)
    m[i] = data + i * cols;
```

<p>
<details style="margin-left: 20px;">
<summary><b>Илюстрация на индексиране на двумерен масив чрез указатели към редове</b></summary>

```
data (continuous block of 12 ints):
+------+------+------+------+------+------+------+------+------+------+------+------+
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
+------+------+------+------+------+------+------+------+------+------+------+------+

Memory addresses: data points here ──► [0]

m (array of 3 pointers to rows):
+---------+---------+---------+
|  m[0]   |  m[1]   |  m[2]   |
+---------+---------+---------+
    |          |         |
    |          |         |
    ▼          ▼         ▼
data + 0*4 data + 1*4 data + 2*4
(points to (points to (points to
element 0) element 4) element 8)

Indexing explanation with pointer arithmetic:

m[0][0] == *(m[0] + 0) == *(data + 0 * cols + 0) == data[0]
m[0][1] == *(m[0] + 1) == *(data + 0 * cols + 1) == data[1]
m[0][2] == *(m[0] + 2) == *(data + 0 * cols + 2) == data[2]
m[0][3] == *(m[0] + 3) == *(data + 0 * cols + 3) == data[3]

m[1][0] == *(m[1] + 0) == *(data + 1 * cols + 0) == data[4]
m[1][1] == *(m[1] + 1) == *(data + 1 * cols + 1) == data[5]
m[1][2] == *(m[1] + 2) == *(data + 1 * cols + 2) == data[6]
m[1][3] == *(m[1] + 3) == *(data + 1 * cols + 3) == data[7]

m[2][0] == *(m[2] + 0) == *(data + 2 * cols + 0) == data[8]
m[2][1] == *(m[2] + 1) == *(data + 2 * cols + 1) == data[9]
m[2][2] == *(m[2] + 2) == *(data + 2 * cols + 2) == data[10]
m[2][3] == *(m[2] + 3) == *(data + 2 * cols + 3) == data[11]
```

</details>
</p>

Плюсове:

- Данните са в един непрекъснат блок (като статичен двумерен масив)
- Cache-friendly
- Лесно копиране и освобождаване

Минуси:

- Малко повече работа при инициализация

**Вариант В (един единствен блок, без `int **`):**

```c
int* m = malloc(rows * cols * sizeof(int));
```

Достъп:

```c
m[i * cols + j]
```

Това повтаря точно row-major подредбата от статичните масиви.

#### 7. Как се подрежда динамичната памет?

Паметта, заделена чрез `malloc`/`calloc`, е **единичен блок** от произволни байтове. Компилаторът **не подрежда автоматично** елементите като масив - всичко се определя от:

- Типа на указателя, към който присвояваме
- Начина на индексация

При:

```c
int* a = malloc(100 * sizeof(int));
```

Физически е точно като:

```c
// Непрекъснат блок от `100 * sizeof(int)` байта
int a_static[100];
```

#### 8. Достъп, адресна аритметика и decay

При динамична памет имаме указатели, затова важат всички правила за адресната аритметика:

```c
a[i] == *(a + i)
```

- `a + i` премества адреса с `i * sizeof(T)`
- Pointer arithmetic работи само спрямо типа

Пример:

```c
double* d = malloc(4 * sizeof(double));

*(d + 3) = 5.0;
```

Позволени аритметични операции с указатели:

```c
p + n   // Напред с `n` елемента
p - n   // Назад с `n` елемента
p++     // Следващ елемент
p--     // Предишен елемент
p2 - p1 // Разстояние в елементи (ако са в един и същ масив)
```

#### 9. Освобождаване на памет. Висящи указатели. Двойно освобождаване

Класически грешки:

- Memory leak (забравен `free`)
	```c
	int* a = malloc(100 * sizeof(int));
	// ...
	// Забравен `free(a);`
	```
- Double `free` (двойно освобождаване)
	```c
	free(a);
	
	// Неопределено поведение
	free(a);
	```
- Dangling pointer (използване след `free`)
	```c
	free(a);
	
	// UB
	a[0] = 5;
	```
	
	Добра практика:
	
	```c
	free(a);
	
	a = NULL;
	```

#### 10. Особености и подводни камъни при `realloc`

При `realloc(p, new_size)` може:

- Да се върне **същият указател** (с размерът променен in-place)
- Да се върне **нов указател** (копирало е блока на друго място)
- Да се върне **NULL** (неуспех - старият блок остава валиден)

Затова винаги:

```c
int* tmp = realloc(p, newsize);

if (tmp != NULL) p = tmp;
else {
    // Указателят `p` си остава валиден и не го губим
}
```

Грешно (рискуваме да загубим указателя):

```c
// Ако върне NULL - memory leak
p = realloc(p, newsize);
```

#### 11. Динамична памет и функции (подаване, връщане)

Понеже резултатът е указател, връщането е лесно:

```c
int* make_array(int n) {
    int* a = malloc(n * sizeof(int));
    return a; // OK - паметта не се унищожава с края на функцията
}
```

> **Бележка:** Задължително внимаваме *кой* е отговорен за освобождаването на паметта (обикновено този, който я е заделил).

Подаване към функция:

```c
void fill(int* a, int n) {
    for (int i = 0; i < n; ++i) a[i] = i;
}

int* x = malloc(10 * sizeof(int));

fill(x, 10);
```

#### 12. Чести грешки и undefined behavior

Излизане извън граници (buffer overflow):

```c
int* a = malloc(5 * sizeof(int));
a[5] = 10; // Извън масива (индексите са 0..4)
```

Забравен `sizeof(T)`:

```c
int* a = malloc(n); // Грешно
```

Освобождаване на памет, която не е заделена динамично:

```c
int x;
free(&x); // UB
```

Освобождаване на частичен адрес вътре в блока:

```c
int* a = malloc(10 * sizeof(int));

free(a + 5); // UB
```