# Област на действие. Разклонено изпълнение. Условни оператори

### Теоретичен обзор

#### 1. Област на действие на променлива

Област на действие на една променлива (на английски *scope*) е частта от програмата, в която тази променлива е "видима" и може да се използва по име.

В езика C, променлива съществува и може да се достъпва **само в областта, в която е декларирана**.

```c
#include <stdio.h>

int main() { // Outer scope
    int a = 10;

    { // Inner scope
        int b = 5;

        printf("Inner scope: a = %d\n", a);
        printf("Inner scope: b = %d\n", b);
    } // Variable `b` is destroyed here

    printf("Outer scope: a = %d\n", a); // Variable `a` is still accessible

    // printf("Outer scope: b = %d\n", b); // ERROR: Variable `b` is not defined here

    return 0;
}
```

Променливата `a` е декларирана в тялото на функцията `main` и е видима **в целия този блок**, докато `b` е декларирана във **вложен блок** и е видима **само вътре в него**.

Variable shadowing:

```c
#include <stdio.h>

int main() {
    int x = 10; // Outer scope variable `x` is defined

    {
        int x = 20; // This declaration hides the outer `x`

        printf("Inner scope: x = %d\n", x);
    } // Inner `x` is destroyed here (outer `x` becomes visible again)

    printf("Outer scope: x = %d\n", x);

    return 0;
}
```

Вътрешната променлива **"засенчва"** външната - докато сме вътре в блока, външното `x` е скрито. След излизане от блока, вътрешното `x` се унищожава и пак получаваме достъп до външната променлива.

Блоковете `{...}` **задават нова област на действие**, като променливите са достъпни и живеят само в своя блок, след което се унищожават и паметта им се освобождава. Въпреки че е възможно да имаме различни променливи с едно и също име в различни области, това е **непрепоръчително**, тъй като води до объркване в кода.

> **Бележка:** След като локалната променлива напусне своята област на действие, нейното име става **недостъпно**, но това **не гарантира моментално физическо освобождаване** на паметта ѝ. При автоматичните променливи паметта се намира в стека и след края на блока тя само се **маркира като свободна** (чрез преместване на стековия указател). Поради това, **старите данни** могат временно да останат на тази локация, докато не бъдат презаписани. Всеки опит за достъп до променлива извън нейната област на действие е **недопустим** и води до **недефинирано поведение**.

#### 2. Разклонено изпълнение

Досега програмите ни се изпълняваха **линейно** - всяка инструкция се обработва в реда, в който е написана, от началото до края. При такова изпълнение **няма възможност за избор** - всичко се случва точно така, както е описано. Например, ако имаме три `printf` оператора, те винаги ще се отпечатат в същия ред. Този подход е прост, но **не позволява програмата да се адаптира** към различни условия.

В реалните програми **почти винаги трябва да се вземат решения** - кое действие да се изпълни и кога. Например, ако дадено условие е изпълнено, извършваме едно действие, а ако не е - друго. Такива решения могат да зависят от въведените данни, от текущото състояние на програмата или от резултатите от предишни изчисления. В програмирането този процес на избор се нарича **разклонение** (на английски *branching*).

Когато искаме програмата да вземе решение, използваме **разклонение**. То проверява дадено условие, което винаги се свежда до *вярно* или *невярно*.

В езика C това става чрез конструкциите `if` и `if-else`. Например, можем да проверим дали въведено число е положително, отрицателно или нула - и програмата да реагира различно във всеки случай.

Така тя вече не върви "по права линия", а може да **избира различен път на изпълнение** в зависимост от обстоятелствата.

```c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main() {
    int age;

    printf("Enter your age: ");
    scanf("%d", &age);

    if (age >= 18) {
        printf("You are eligible to vote.\n");
    }
    else {
        printf("You are not yet eligible to vote.\n");
    }

    return 0;
}
```

Тук програмата проверява дали `age` е по-голямо или равно на 18. Ако условието е вярно, се изпълнява първият блок, а ако е невярно - блокът след `else`. По този начин програмата избира кой път на изпълнение да следва и реагира различно според въведената стойност.

Без разклонение програмите биха могли само да изпълняват **статичен ред от инструкции**, което значително ограничава тяхната функционалност. Разклоненията са основата на адаптивността и интерактивността в програмирането и в комбинация с цикли и функции позволяват реализирането на сложни алгоритми.

#### 3. Бинарно и каскадно разклоняване (`if` и тернарен оператор)

| Оператор | Синтаксис | Дефиниция и механизъм | Кога се използва? |
|----------|----------|----------|----------|
| `if` | `if (условие) {...}` | Проверява **логически израз**. Ако резултатът е ненулев (истина), изпълнява кода в блока. Ако е лъжа, "прескача" блока. | За прости, единични проверки, където не е необходимо алтернативно действие. |
| `if-else` | `if (условие) {...} else {...}` | Осигурява **двупътно разклонение**. Изпълнява блока на `if`, ако условието се евалюира до истина, или блока на `else` в противен случай. | За избор между две **взаимно изключващи** се действия. |
| `if-else if-else` | `if (у1) {...} else if (у2) {...} else {...}` | Създава **каскада от проверки**. Условията се оценяват последователно. Изпълнява се **само кодът на първото вярно условие**, след което структурата приключва. | За избор между **множество** (повече от две) взаимно изключващи се условия. |
| `?:` | `резултат = (условие) ? израз1 : израз2;` | Единствената **тернарна операция** в C. Тя е **израз** (връща стойност), а не оператор за контрол на потока. Връща `израз1`, ако условието е изпълнено, и `израз2` в противен случай. | За кратко и елегантно **присвояване на стойност** въз основа на просто условие. |

Проблемът с "висящото" `else` представлява синтактично двусмислие, което възниква при вложени оператори `if`, когато липсват фигурни скоби за дефиниране на блоковете код. В езика C съществува правило, според което всеки `else` се асоциира с най-близкия предшестващ `if`, който все още няма съответстващо `else`. Това поведение може да доведе до неочаквани резултати, ако логическата структура на кода не е ясно дефинирана.

Например, без допълнителни правила, изразът `if (a) if (b) s; else s2;` може да се интерпретира двусмислено като един от следните два варианта:

```
// Variant 1
if (a) {
    if (b) s;
    else s2;
}

// Variant 2
if (a) {
    if (b) s;
}
else s2;
```

Препоръчително е винаги да се използват фигурни скоби, за да се уточни към кой `if` принадлежи всеки `else` и да се предотвратят потенциални грешки.

#### 4. Многопътно дискретно разклоняване (`switch`)

Многопътното дискретно разклоняване чрез конструкцията `switch` позволява избор между множество възможни действия в зависимост от стойността на даден израз-селектор. Обикновено този израз е от целочислен тип, а всяка възможна алтернатива се задава чрез `case` етикет, който представлява **целочислена константа** - стойност, фиксирана по време на компилация. Тази структура улеснява четимостта и поддръжката на кода, когато се налага да се сравнява една променлива с множество възможни стойности.

```c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main() {
    int day;

    printf("Enter a day (1-7): ");
    scanf("%d", &day);

    switch (day) {
    case 1: printf("Monday\n"); break;
    case 2: printf("Tuesday\n"); break;
    case 3: printf("Wednesday\n"); break;
    case 4: printf("Thursday\n"); break;
    case 5: printf("Friday\n"); break;
    case 6: printf("Saturday\n"); break;
    case 7: printf("Sunday\n"); break;
    default: printf("Invalid day\n"); break;
    }

    return 0;
}
```

Стойността на `day` се сравнява с `case` стойностите. Изпълнението започва от първото съвпадение надолу, докато не срещне `break` или края на `switch` блока. Операторът `break` **незабавно прекъсва** изпълнението на `switch` блока.

Fall-through (пропадане):

- По подразбиране, след намиране на съвпадение, изпълнението **продължава последователно** през следващите `case`-ове, докато не се срещне `break`
- Умишлено се използва за **групиране на случаи** с общ код

```c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main() {
    char ch;

    printf("Enter a letter: ");

    // Basic error handling
    if (scanf(" %c", &ch) != 1) {
        return 1;
    }

    switch (ch) {
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        // All 10 cases execute this single line of code
        printf("Vowel letter\n"); break;
    default:
        printf("Consonant letter or non-alphabetic character\n"); break;
    }

    return 0;
}
```

Всички гласни букви водят до изпълнение на един и същи блок.

#### 5. Деклариране на променливи в `switch`

В C целият `switch` блок се третира като един основен `scope`. Ако направим декларация и инициализация на променлива директно в `case` (без вътрешен блок), компилаторът отчита проблем.

```c
switch (k) {
case 1:
	// Initialization
	int val = 10 * k; break;
case 2:
	// Invalid (may jump over initialization)
	printf("%d\n", val); break;
}
```

Решението е да оградим декларацията във вътрешен блок `{ }`, който ограничава `scope`-а само до съответния `case`:

```c
switch (k) {
case 1: {
	int val = 10 * k;
	
	printf("%d\n", val);
	
	break;
}
case 2:
	// Variable `val` does not exist here
	break;
}
```

Сега другите `case`-ове не могат да видят `val`, защото е локална само за блока на първия `case`. Това предотвратява конфликти и грешки при компилация.

---

### Полезни съвети

| Принцип | Цел |
|----------|----------|
| Използвайте `{ }` в `case` клонове | Избягва грешки при инициализация и ограничава обхвата на променливите. |
| Декларирайте променливи преди `switch` | Позволява достъп до тях във всички `case` клонове. |
| Не пропускайте `break` | Предотвратява нежелано "пропадане" към следващ `case`. |
| Добавяйте `default` | Осигурява обработка на непокрити стойности. |

---

### Допълнителни ресурси

- [Dangling Else](https://en.wikipedia.org/wiki/Dangling_else)
- [Scope Rules in C](https://www.geeksforgeeks.org/c/scope-rules-in-c/)