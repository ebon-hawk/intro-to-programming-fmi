# Указатели към функции

## 1. Какво представляват указателите към функции?

В C всяка функция заема определено място в паметта на програмата. Името на функцията всъщност представлява нейния **начален адрес**.

**Указателят към функция** е променлива, която съхранява този адрес. Вместо да извикваме функцията директно по име, можем да я извикаме чрез адреса, записан в указателя.

---

## 2. Синтаксис и дефиниране

Синтаксисът изглежда малко странно, защото трябва да укажем точно каква е *сигнатурата* на функцията (какъв тип връща и какви параметри приема).

**Общ вид:** `тип_на_връщане (*име_на_указателя)(типове_аргументи);`

Ако имаме функция:

```c
int add(int a, int b) {
    return a + b;
}
```

Указателят към нея ще изглежда така:

```c
int (*ptr)(int, int); // Дефиниция на указател
ptr = &add;           // Присвояваме адреса на функцията (може и без &)
```

> **Важно:** Скобите около `*ptr` са задължителни. Ако напишете `int *ptr(int, int)`, C ще го интерпретира като функция, която връща указател към `int`.

---

## 3. Защо са ни нужни?

Указателите към функции ни позволяват да предаваме логика като аргумент на други функции. Това се нарича *callback* (обратно извикване).

Основни приложения:

- **Сортиране:** Можем да напишем общ алгоритъм за сортиране и да му подадем указател към функция, която определя как точно да се сравняват два елемента (например възходящо или низходящо)
- **Менюта:** Вместо дълги `switch` конструкции, можем да имаме масив от указатели към функции
- **Event-driven програмиране:** Реакция при натискане на бутон

---

## 4. Използване на `typedef` за яснота

Синтаксисът на указателите към функции бързо става труден за четене, особено ако се предава като аргумент. `typedef` ни позволява да създадем "псевдоним" за типа на указателя.

**Без typedef:**

```c
void execute(int (*operation)(int, int), int x, int y) { ... }
```

**С typedef:**

```c
typedef int (*BinaryOp)(int, int); // Дефинираме нов тип BinaryOp

void execute(BinaryOp op, int x, int y) {
    printf("Result: %d\n", op(x, y));
}
```

Сега `BinaryOp` може да се използва като всеки друг тип (`int`, `char`).

---

## 5. Пълен пример за програма

Ето как можем да сменим поведението на програмата в движение:

```c
#include <stdio.h>

typedef int (*Operation)(int, int);

int multiply(int a, int b) { return a * b; }
int add(int a, int b) { return a + b; }

int main() {
    int x = 10, y = 5;
    Operation op; // Създаваме променлива от нашия нов тип

    // Насочваме към събиране
    op = add;
    printf("Sum: %d\n", op(x, y));

    // Насочваме към умножение
    op = multiply;
    printf("Product: %d\n", op(x, y));

    return 0;
}
```

---

## 6. Масиви от указатели към функции

Това е изключително удобно за менюта. Можете да извикате функция просто по нейния индекс в масива:

```c
Operation menu[] = { add, multiply };
int choice = 1; // Умножение
int result = menu[choice](10, 2); // Извиква multiply(10, 2)
```