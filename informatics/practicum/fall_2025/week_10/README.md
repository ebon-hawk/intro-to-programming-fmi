# Многомерни масиви

### Теоретичен обзор

#### 1. Какво представлява многомерният масив?

В програмирането често ни трябва **структура, която представя стойности, разположени в две или повече направления** - например стойности по редове и колони (матрица), тримерни данни (куп таблици) или таблица от записи. Тази цел се постига чрез **многомерни масиви** - масиви, чиито елементи сами са масиви.

- Масив, чиито елементи са едномерни масиви, е двумерен масив
- Масив, чиито елементи са двумерни масиви, е тримерен масив

> **Бележка:** Формално можем да имаме `N`-мерен масив (`N` >= 1), но на практика се работи най-често до 3 измерения - повече от това е рядкост и усложнява интуицията.

#### 2. Тип и синтаксис

Тип на `N`-мерен масив:

```c
T name[size1][size2]...[sizeN];
```

- Това е масив със `size1` елемента
- Всеки елемент е масив от тип `T [size2]...[sizeN]`
- `T` е базовият тип на елементите (например `int`, `double` и т.н.)

Примери:

```c
// Двумерен масив (5 реда, всеки ред е int[3])
int a[5][3];

// Тримерен масив (4 слоя, всеки е double[5][3])
double d[4][5][3];
```

Интерпретация:

- `int a[5][3]` - едномерен масив с 5 елемента, всеки от които е `int[3]` (масив от 3 `int`-а)
- `double d[4][5][3]` - едномерен масив с 4 елемента, всеки от които е `double[5][3]` (двумерен масив 5×3)

#### 3. Множество от стойности (семантика на типа)

Множеството от допустими стойности за типа `T[size1][size2]...[sizeN]` е множеството от всички редици/таблици, където всеки компонент е от базовия тип `T` и размерите съвпадат.

Формално - това са всички възможни таблици с размер `size1 × size2 × ... × sizeN` елементи от тип `T`.

#### 4. Как се подрежда в паметта (физическа организация)

В C многомерните масиви са **единичен непрекъснат блок памет**, подреден в **row-major** ред (ред по ред).

За двумерен масив `T a[R][C]` елементите са записани така:

```c
a[0][0], a[0][1], ..., a[0][C - 1], a[1][0], a[1][1], ..., a[R - 1][C - 1]
```

Адресът на елемент `a[i][j]` се изчислява като:

```c
address(a[i][j]) = address(a) + ((i * C) + j) * sizeof(T)
```

За тримерен `T b[D][R][C]`:

```c
address(b[i][j][k]) = address(b) + ((i * R * C) + (j * C) + k) * sizeof(T)
```

Примерна паметна карта (двумерен масив 2×3):

```c
double c[2][3] = { { 1.5, 2.3, 4.3 }, { 4.0, 5.1, 6.9 } };
```

- Памет (последователно): `1.5, 2.3, 4.3, 4.0, 5.1, 6.9`
- Индекси: `[0][0], [0][1], [0][2], [1][0], [1][1], [1][2]`

Ако имаме:

```c
int matrix[3][5];
```

Брой колони (всеки ред е масив от 5 int-а): `columns = sizeof(matrix[0]) / sizeof(matrix[0][0])`

- `sizeof(matrix[0])` → размер на един ред
- `sizeof(matrix[0][0])` → размер на един елемент

Брой редове: `rows = sizeof(matrix) / sizeof(matrix[0])`

- `sizeof(matrix)` → целият двумерен масив
- `sizeof(matrix[0])` → един ред

#### 5. Декларация и (частична) инициализация

Декларация:

```c
T name[size1][size2]...[sizeN];
```

Пълна инициализация:

```c
int b[3][2] = { { 1, 0 }, { 0, 1 }, { 1, 1 } };
```

Инициализация без вложени фигурни скоби (компилаторът маршрутизира стойностите в row-major ред):

```c
// Същото като { { 1.5, 2.3, 4.3 }, { 4.0, 5.1, 6.9 } }
double c[2][3] = { 1.5, 2.3, 4.3, 4.0, 5.1, 6.9 };
```

- **Частична инициализация:** Неразпределените елементи се инициализират с нула (особено при статични/глобални данни или когато използваме `{ 0 }`)
- **Автоматично определяне на първото измерение:** Може да се остави първото измерение празно при инициализация (компилаторът ще определи неговата стойност от броя на вложените редици)

```c
// R = 2, C = 3
int m[][3] = { { 1, 2, 3 }, { 4, 5, 6 } };
```

#### 6. Достъп до елемент по индекс

Синтаксис:

```c
name[index1][index2]...[indexN]
```

Примери:

```c
double c[2][3];
c[0][0] = 1.5;
double x = c[1][2];
```

- `c[0]` е от тип `double[3]` - едномерен масив, който може да се индексира отново
- Както при едномерните масиви, C **не проверява** при изпълнение дали индексите са в допустимия диапазон - извън-индексиране води до *undefined behavior*

Адресна аритметика (важно за разбирането на типовете):

- За `int a[R][C];` идентификаторът `a` в повечето изрази *decay*-ва до `&a[0]` с тип `int (*)[C]` - указател към масив от `C` на брой `int`-а
- `a[i]` е от тип `int[C]` (който може да *decay*-не до `int *`, когато е нужно)

Пример:

```c
// p е указател към масив от C int-а
int (*p)[C] = a;

// q е указател към a[0][0]
int *q = a[0];
```

#### 7. Array-to-pointer decay за многомерни масиви

Ключови моменти:

- `a` (когато `a` е `T a[R][C]`) *decay*-ва към `&a[0]`, тип `T (*)[C]`
- `a[i]` *decay*-ва към `&a[i][0]`, тип `T *`

Следователно:

```c
int a[5][3];

// p сочи към първия ред (тип: pointer-to-array-of-3-int)
int (*p)[3] = a;

// q сочи към a[0][0]
int *q = a[0];
```

Разликата спрямо едномерните масиви е в типа: `p + 1` прескача **цял ред** (3 `int`-а), защото `sizeof(*p) == 3 * sizeof(int)`.

#### 8. Многомерни масиви като формални параметри на функции

Когато подаваме многомерен масив като аргумент на функция, **трябва да укажем всички размери, освен първия**, защото компилаторът трябва да знае "широчината" на всеки ред, за да може да пресмята адресите.

Два еквивалентни синтаксиса:

```c
void process(int a[][10], unsigned rows, unsigned cols);
```

или

```c
void process(int (*a)[10], unsigned rows, unsigned cols);
```

- `int a[][10]` означава, че параметърът е указател към масив от 10 `int`-а (първото измерение - брой редове - може да варира)
- Непозволено е да оставиш **и** второто (и следващите) измерения непосочени - компилаторът се нуждае от тях, за да знае какво е `sizeof(*a)`

Пример:

```c
int matrix[5][5];

// Ако process е декларирана да очаква int a[][5], това е правилно
process(matrix, 5, 5);
```

#### 9. Итериране: по редове или по колони?

Поради row-major подредба, итерацията *по редове* (външен цикъл = редове, вътрешен = колони) е по-ефективна от итерация *по колони*, защото последователните паметни достъпи са кеш-локални.

По-добър (cache-friendly) начин:

```c
for (unsigned i = 0; i < R; ++i) {
    for (unsigned j = 0; j < C; ++j) {
	    // Последователни адреси в паметта
		process(a[i][j]);
	}
}
```

По-малко подходящ за performance:

```c
for (unsigned j = 0; j < C; ++j) {
    for (unsigned i = 0; i < R; ++i) {
	    // Прескачаме между редовете - повече кеш-пропуски
	    process(a[i][j]);
	}
}
```

При малки масиви разликата е незначителна; при големи - може да е голяма.

#### 10. Адресни и типови нюанси - примери с указатели

```c
int A[3][4];

// Типове и свойства:
A                 // decay: int (*)[4]
A + 1             // тип: int (*)[4], адрес на втори ред (прескача 4 int-а)
A[0]              // тип: int [4], decay: int *
& A[0][0]         // тип: int *
```

Пример с указател към масив:

```c
int (*p)[4] = A;  // p + 1 е адресът на A[1]
printf("%d\n", *(*p + 2)); // еквивалентно на A[0][2]
```

Сравнения:

```c
if (A == &A[0]) { /* true */ }  // A decay-ва към &A[0]
```

#### 11. Копиране и сравнение

Многомерни статични масиви **не могат да се присвояват** директно:

```c
int a[2][3], b[2][3];
// a = b; // компилационна грешка
```

Копиране по редове (за кеш-ефективност):

```c
for (unsigned i = 0; i < rows; ++i)
    for (unsigned j = 0; j < cols; ++j)
        dest[i][j] = src[i][j];
```

#### 12. Частична инициализация и default стойности

Ако инициализираме частично, останалите елементи се нулират:

```c
int t[2][3] = { {1, 2}, {3} }; // еквивалентно на {{1,2,0}, {3,0,0}}
```

Локални масиви без инициализация имат неопределени стойности (освен ако са декларирани статично/глобално).

#### 13. Операции "над диагонали" (главен и вторичен диагонал)

За квадратна матрица `N × N`:

- **Главен диагонал**: елементите `a[i][i]` за `i = 0..N-1`.
- **Вторичен диагонал**: елементите `a[i][N-1-i]`.

Примери:

```c
// Сумиране на главния диагонал
int sum_main = 0;
for (unsigned i = 0; i < N; ++i) sum_main += a[i][i];

// Сумиране на вторичния диагонал
int sum_secondary = 0;
for (unsigned i = 0; i < N; ++i) sum_secondary += a[i][N-1-i];
```

Под/над диагонала:

- Елементи под главния диагонал: `i > j`
- Елементи над главния диагонал: `i < j`