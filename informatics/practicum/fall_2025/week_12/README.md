# Символни низове. Стандартни функции за работа със символни низове

### Теоретичен обзор

В **C** няма вграден тип *string* както в по-високите езици. Вместо това низовете се представят като **масиви от символи**, които **задължително завършват с терминираща нула** - `\0`. Цялата стандартна библиотека за работа с низове е изградена върху това просто, но много важно правило.

#### 1. Какво е символен низ в C?

**Низът** е последователност от символи от тип `char`, разположени в **непрекъсната памет**, като **краят на низа** се отбелязва със символа `\0` (*ASCII* код 0).

Пример за низ в паметта:

```
Адрес:   Стойност:
0x1000 → 'a'
0x1001 → 'b'
0x1002 → 'c'
0x1003 → '\0'
```

```c
char str[] = "abc";
```

Тук компилаторът **автоматично** добавя `\0` в края.

> **Бележка:** Всички стандартни функции (`strlen`, `strcpy`, `strcmp` и др.) четат символи, докато не срещнат `\0`. Ако липсва терминираща нула, получаваме *undefined behavior* (четене извън масива).

#### 2. Деклариране и инициализация на низове

<p>
<details style="margin-left: 20px;">
<summary><b>Като масив от <code>char</code></b></summary>

```c
char s1[] = "Hello";
```

Еквивалентно на:

```c
char s1[] = { 'H', 'e', 'l', 'l', 'o', '\0' };
```

Характеристики:

- Размерът се определя автоматично
- Масивът е **модифицируем**

```c
s1[0] = 'h'; // OK
```

</details>
<details style="margin-left: 20px;">
<summary><b>С фиксиран размер</b></summary>

```c
char s2[10] = "abc";
```

Паметно представяне:

```
[a][b][c][\0][?][?][?][?][?][?]
```

- Останалите клетки са неинициализирани
- Низът пак завършва на първата `\0`

Опасност:

```c
char s3[3] = "abc"; // ГРЕШНО
```

Няма място за `\0` (невалиден низ).

</details>
<details style="margin-left: 20px;">
<summary><b>Низов литерал и указател</b></summary>

```c
const char* s4 = "abc";
```

- `"abc"` е **литерал**, съхранен в **статична памет**
- Съдържанието **НЕ трябва да се променя**

```c
s4[0] = 'A'; // Undefined behavior
```

Затова винаги използваме `const char*`.

> **Бележка:** Литералите като `"abc"` се съхраняват в статичната *read-only* памет на програмата - това е място, което е постоянно и споделено, но **не трябва да се променя**. Затова указател като `const char* p = "abc";` сочи към тази защитена памет и опитът да се промени съдържанието (напр. `p[0] = 'A';`) води до *undefined behavior*. Обратно, когато декларираме масив като `char s[] = "abc";`, компилаторът създава отделно, модифицируемо копие на литерала в локална или статична памет, което може да се променя безопасно.

</details>
</p>

#### 3. Функции за въвеждане и извеждане на низове

- `fgets(char *str, int n, FILE *stream)`
	- Чете до `n - 1` символа или докато се срещне `\n` от даден входен поток
	- Включва и новия ред в буфера (ако е прочетен)
	- Добавя автоматично терминираща нула
	- За разлика от `scanf("%s", ...)`, не спира на първия *whitespace*, а прочита целия ред (до лимита)
	
	```c
	char buffer[100];
	fgets(buffer, 100, stdin);
	```
- `puts(const char *str)`
	- Извежда низ на стандартния изход, след което добавя нов ред
- `gets()`
	- Небезопасна
	- Води до препълване на буфера
- `getchar()`
	- Чете един символ от стандартния вход (`stdin`)
	- Връща прочетения символ като `int` (или `EOF`, ако е краят на файла)

> **Бележка:** Често `getchar()` се използва, когато трябва да се чете символ по символ, например при писане на собствена функция за въвеждане на низ, без да се използват `scanf` или `fgets`.

#### 4. Функции за сравнение и копиране

- `strcmp(const char *s1, const char *s2)`
	- Сравнява два низа лексикографски
	- Връща 0 при равенство, отрицателно число ако `s1 < s2`, положително число ако `s1 > s2`
- `strncmp(const char *s1, const char *s2, size_t n)`
	- Сравнява само първите `n` символа
- `strcpy(char *dest, const char *src)`
	- Копира низа от `src` в `dest` (предполага, че има достатъчно място)
- `strncpy(char *dest, const char *src, size_t n)`
	- Копира до `n` символа
	- Може да не добави терминална нула, ако `src` е по-дълъг от `n`

#### 5. Функции за дължина и търсене

- `strlen(const char *str)`
	- Връща дължината на низа (без терминалната нула)
- `strstr(const char *haystack, const char *needle)`
	- Търси подниз `needle` в `haystack`
	- Връща указател към началото на първата поява или `NULL`

#### 6. Функции за конкатенация

- `strcat(char *dest, const char *src)`
	- Добавя `src` накрая на `dest` (предполага, че има достатъчно място)
- `strncat(char *dest, const char *src, size_t n)`
	- Добавя до `n` символа от `src`