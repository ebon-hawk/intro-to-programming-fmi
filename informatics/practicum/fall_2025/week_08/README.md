# Едномерни масиви

### Теоретичен обзор

#### 1. Какво представлява масивът?

В програмирането често се налага да работим с **няколко стойности, които имат общо предназначение** - например всички оценки на ученик, всички температури за седмицата или всички скорости, измерени по време на експеримент. Вместо да създаваме много отделни променливи, ние **групираме тези логически свързани данни** в структура, наречена **едномерен масив** (*array*).

Такъв масив има следните свойства:

- Съдържа **краен брой елементи**, предварително определен
- **Всички елементи са от един и същи тип**
- Елементите са **подредени последователно в паметта**
- Достъпът до всеки елемент става чрез **целочислен индекс**, започващ от 0

Индексът играе ролята на **позиция** на елемента в групата - чрез него можем бързо да четем или променяме стойностите.

Примерна аналогия (пощенски кутии в редица):

| Кутия № | 0 | 1 | 2 | 3 |
|------|------|------|------|------|
| Писмо | 5 | 9 | 14 | 20 |

- Всяка кутия съхранява **една стойност**
- Всички кутии са **еднакъв размер**
- За да извадиш писмо, не търсиш наред - просто казваш **индекс 2 → 14**

Точно така работи и масивът - чрез **пряк достъп** по номер на позицията.

| Ако нямаме масиви | Ако използваме масиви |
|------------------|------------------|
| Много отделни променливи | Всичко е събрано на едно място |
| Трудна обработка (цикли, търсене, суми и др.) | Лесна обработка чрез индекси и цикли |
| Няма общ смисъл между отделните стойности | Данните са **организирани** и **логично групирани** |

#### 2. Абстракция и паметна организация на масива

Логическа представа (как го вижда програмистът):

- Масивът съдържа `N` **последователно подредени стойности**
- Всеки елемент е **от един и същи тип**
- Всеки елемент се достъпва чрез **индекс** от 0 до `N - 1`
- Третираме всички елементи като **една група с общ смисъл**

Физическа реализация (как се съхранява в паметта):

- За масива се заделя **непрекъснат блок памет**
- Всеки елемент има **фиксиран размер** (например `sizeof(int) = 4` байта)
- Индексът се използва за **адресна аритметика**

Пример в C:

```c
// Allocates 4 * sizeof(int) bytes of contiguous memory
int arr[4];
```

Ако `sizeof(int) = 4`, за `arr` се заделят **16 последователни байта**.

Да приемем, че първият елемент се разполага на адрес 1000:

| Индекс (`k`) | Елемент (`arr[k]`) | Адрес в паметта |
|------------------|------------------|------------------|
| 0 | `arr[0]` | 1000 |
| 1 | `arr[1]` | 1004 |
| 2 | `arr[2]` | 1008 |
| 3 | `arr[3]` | 1012 |

Адресът на елемент `k` се изчислява директно: `address(arr[k]) = address(arr) + k * sizeof(type)`.

Тоест индексът казва на компютъра колко елемента да "прескочи" напред в паметта, за да стигне до желания. Затова достъпът до елемент по индекс се осъществява за константно време.

#### 3. Какво е указател в езика C?

В програмите всички данни се съхраняват в паметта и всеки байт от нея има **уникален адрес** - число, което показва *къде* се намира дадена стойност.

**Указателят** е променлива, която **съхранява именно такъв адрес**. Вместо да държи стойност, указателят пази *къде* в паметта е записана тази стойност.

```c
// Variable `x` contains the value 10
int x = 10;

// Pointer `p` contains the address of variable `x`
int *p = &x;
```

Така:

```c
// Outputs 10
printf("%d\n", *p);
```

> **Бележка:** Изразът `*p` означава "иди на адреса, съхранен в `p`, и прочети стойността там".

Типът на указателя **не описва самия указател**, а описва какъв тип данни ще намерим на адреса, който указателят съхранява.

```c
// Variable `p` points to an integer value in memory
int *p;

// Variable `q` points to a character value in memory
char *q;
```

#### 4. Array-to-Pointer Decay

В езика C името на масив (например `arr`) **не е** променлива - то е **етикет** (*compile-time identifier*), който обозначава **цял блок от памет**. То **не може да се присвоява** и **не е указател**, въпреки че често се държи като такъв.

В повечето изрази, идентификаторът `arr` автоматично се **преобразува** до `&arr[0]` - указател (*pointer*) към първия елемент от масива.

Пример:

```c
int arr[4] = {10, 20, 30, 40};

// Identifier `arr` "decays" to `&arr[0]`
int *p = arr;
```

Тук `p` и `arr` сочат към **един и същи адрес**, но са различни като **тип** и **поведение**.

Изключения, при които идентификаторът **не се преобразува**:

| Израз | Какво означава | Резултат |
|------------------|------------------|------------------|
| `sizeof(arr)` | Измерва цялата заделена памет за масива | Връща `N * sizeof(type)` |
| `&arr` | Адрес на целия масив като един обект | Тип "указател към масив" (`int (*)[N]`) |

Пример за разлика:

```c
// 4 * sizeof(int) = 16 bytes
unsigned int res1 = sizeof(arr);

// Size of a pointer (e.g., 8 bytes on a 64-bit system)
unsigned int res2 = sizeof(&arr);
```

Тук се вижда ясно:

- `arr` → **не е указател**, иначе `sizeof(arr)` щеше да връща размера на указател
- `&arr` → **указател към целия масив**, не към първи елемент

Да си представим масива като влак с вагони:

- `arr` → **целият влак**
- `arr + 1` → "премести се до следващия вагон"
- `&arr` → адресът на **целия влак**
- `&arr[0]` → адресът на **първия вагон**

**Decay** означава "направи така, че името на влака да действа като указател към първия вагон".

| Понятиe | Какво е в C | Какво представлява |
|------------------|------------------|------------------|
| `arr` | Име на масив | Адрес на първи елемент (в повечето случаи) |
| `&arr[0]` | Указател към елемент | Абсолютен адрес на първия елемент |
| `&arr` | Указател към масив | Адрес на целия блок |
| `arr[i]` | Достъп по индекс | `*(arr + i)` |

**Array-to-pointer decay** е начинът, по който масивите и указателите работят заедно, но това **не ги прави еднакви**.

#### 5. Декларация

Синтаксис:

```c
T name[CAPACITY];
```

Важни правила:

- Капацитетът се знае при компилация
- Трябва да е **положителен константен израз**
- **Не може да се променя** - масивът е *статична структура*

```c
#define CAPACITY 4

// Array of 4 integer values
int rank[CAPACITY];
```

Честа грешка:

```c
// Variable `a` is a double, `b` is an array of 5 doubles
double a, b[5];

// Both `a` and `b` are arrays of 5 doubles each
double a[5], b[5];
```

#### 6. Инициализация

Частична инициализация:

```c
// The rest is filled with 0.0 → {3.40, 5.25, 6.00, 0.00, 0.00}
double grades[5] = {3.40, 5.25, 6.00};
```

Автоматичен размер:

```c
// Size becomes 3
int rank[] = {2, 3, 4};
```

Инициализация с нули:

```c
// All elements become 0
int q[6] = {0};
```

#### 7. Достъп до елементи

Всеки елемент се намира чрез своя индекс - цяло число, което започва от 0 и достига до `CAPACITY - 1`. Например, ако масивът има капацитет 5, валидните индекси са 0, 1, 2, 3 и 4.

```c
// Array with 5 elements
int g[5];

// Writing value to element at index 3
g[3] = 4.75;

// Reading values at indices 1 and 2
int x = g[1] + g[2];
```

C не проверява дали индексът е валиден по време на изпълнение (*runtime*). Ако използваме индекс извън допустимия диапазон, това води до **undefined behavior** - програмата може да се срути, да върне неправилни стойности или да повреди паметта.

```c
// Invalid index (no compiler error, but unpredictable result)
g[100000] = 42;
```

Трябва **ръчно да проверяваме дали индексът е валиден**, преди да достъпваме данни. Това означава да сме сигурни, че индексът е по-голям или равен на 0 и по-малък от капацитета на масива.

> **Бележка:** Защо C не прави проверка? Липсата на автоматична проверка ускорява изпълнението, тъй като не се добавя допълнителен код за всяка операция. Това е проектирано така, за да е възможна максимална производителност при системно програмиране и вградени системи. Въпреки това е важно да сме внимателни и да пишем надежден код, който не нарушава границите на масива.

#### 8. Капацитет срещу реален брой елементи

В практиката често масивът е по-голям от броя на използваните към момента елементи. Това означава, че:

- **Капацитетът** е максималният брой елементи, който масивът може да съхранява (той се определя при декларация и остава фиксиран)
- **Реалният брой елементи** (или текущият размер) е колко от тези елементи са вече използвани или валидни към дадения момент

Пример:

```c
int arr[100];
unsigned int size = 0;

int element = 123;

arr[size++] = element;
```

- Масивът `arr` има капацитет за 100 цели числа
- Променливата `size` следи колко елемента са вече записани
- При всяко добавяне на нов елемент, той се поставя на позиция `size`, след което `size` се увеличава с 1

Този подход е много разпространен при работа със статични масиви в C, тъй като езикът не поддържа автоматично следене на техния реален размер. Управлението му е отговорност на програмиста и е ключово за коректна и безопасна работа с масиви.

#### 9. Масиви като параметри на функции

В езика C, когато подаваме масив като аргумент на функция, **не се копира целият масив**. Вместо това, функцията получава **адреса на първия елемент** на масива.

Масивът е последователен блок памет, а функцията работи с указател (*pointer*) към началото на този блок. Това прави подаването много ефективно - не се създава допълнително копие на данните, а се манипулират **оригиналните стойности**.

```c
// Equivalent to `void f(int* a);`
void f(int a[]);
```

Вътре във функцията параметърът `a` е указател към `arr[0]` - първия елемент на масива.

Какво означава това на практика? Промените върху елементите на масива вътре във функцията засягат **оригиналния масив** извън нея:

```c
// Modifies the original array
void change(int x[]) { x[0] = 999; }
```

За да знае функцията колко елемента да обработва, размерът на масива трябва да се подава като отделен параметър:

```c
void process(int arr[], unsigned int size);
```

Така функцията може да използва този размер, за да не излиза извън границите на масива и да работи безопасно.

#### 10. Поддържани и неподдържани операции

В езика C някои операции с масиви **не са директно поддържани**, защото масивът не е променлива с директна стойност, а представлява блок памет, адресиран чрез указател.

| Операция | Причина защо не работи |
|------------------|------------------|
| Присвояване (`a = b`) | Това би копирало адреса, което не е валидно, тъй като масивите не могат да се "пренасочват" |
| Сравнение (`a == b`) | Сравняват се адресите на масивите, а не съдържанието им |

Примери:

```c
int a[5], b[5];

// Invalid operation (compilation error)
// a = b;

// Comparison checks for address equality, NOT element-wise equality
if (a == b) { ... }
```

Как да се работи с масиви при нужда от копиране и сравнение? Като се имплементират **поелементни функции**, които копират или сравняват елемент по елемент:

```c
int equal(int a[], int b[], unsigned int size) {
    for (unsigned int i = 0; i < size; ++i) {
        if (a[i] != b[i]) return 0;
    }

    return 1;
}

void copyArray(int dest[], int src[], unsigned int size) {
    for (unsigned int i = 0; i < size; ++i) {
        dest[i] = src[i];
    }
}
```